\documentclass[letterpaper,compsoc,twoside,onecolumn]{IEEEtran}
% generated by Docutils <http://docutils.sourceforge.net/>
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{color}

\usepackage[font={small,it},labelfont=bf]{caption}
\usepackage{float}

\setcounter{secnumdepth}{0}

%%% Custom LaTeX preamble
\usepackage{scipy}
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@cs}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PY@bc##1{{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\@namedef{PY@tok@ne}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\@namedef{PY@tok@nl}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\@namedef{PY@tok@nd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@si}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@ges}{\let\PY@bf=\textbf\let\PY@it=\textit}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


%%% User specified packages and stylesheets

%%% Fallback definitions for Docutils-specific commands

% class handling for environments (block-level elements)
% \begin{DUclass}{spam} tries \DUCLASSspam and
% \end{DUclass}{spam} tries \endDUCLASSspam
\ifx\DUclass\undefined % poor man's "provideenvironment"
 \newenvironment{DUclass}[1]%
  {\def\DocutilsClassFunctionName{DUCLASS#1}% arg cannot be used in end-part of environment.
     \csname \DocutilsClassFunctionName \endcsname}%
  {\csname end\DocutilsClassFunctionName \endcsname}%
\fi
% basic code highlight:
\providecommand*\DUrolecomment[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUroledeleted[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUrolekeyword[1]{\textbf{#1}}
\providecommand*\DUrolestring[1]{\textit{#1}}

% inline markup (custom roles)
% \DUrole{#1}{#2} tries \DUrole#1{#2}
\providecommand*{\DUrole}[2]{%
  % backwards compatibility: try \docutilsrole#1{#2}
  \ifcsname docutilsrole#1\endcsname%
    \csname docutilsrole#1\endcsname{#2}%
  \else
    \csname DUrole#1\endcsname{#2}%
  \fi%
}

% legend environment
\ifthenelse{\isundefined{\DUlegend}}{
  \newenvironment{DUlegend}{\small}{}
}{}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \usepackage{bookmark}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}


%%% Body
\begin{document}
\newcounter{footnotecounter}\title{Cell Tracking in 3D using deep learning segmentations}\author{Varun Kapoor$^{\setcounter{footnotecounter}{3}\fnsymbol{footnotecounter}\setcounter{footnotecounter}{1}\fnsymbol{footnotecounter}}$%
          \setcounter{footnotecounter}{1}\thanks{\fnsymbol{footnotecounter} %
          Corresponding author: \protect\href{mailto:varun.kapoor@curie.fr}{varun.kapoor@curie.fr}}\setcounter{footnotecounter}{3}\thanks{\fnsymbol{footnotecounter} Institut Curie, PSL Research University, Sorbonne University, CNRSUMR 3215, INSERM U934, Genetics and Developemental Biology, Paris, France.}, Claudia CarabaÃ±a$^{\setcounter{footnotecounter}{3}\fnsymbol{footnotecounter}}$\thanks{%

          \noindent%
          Copyright\,\copyright\,2025 Varun Kapoor et al. This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.%
        }}\maketitle
          \renewcommand{\leftmark}{PROC. OF KAPOORLABS}
          \renewcommand{\rightmark}{CELL TRACKING IN 3D USING DEEP LEARNING SEGMENTATIONS}
        
\InputIfFileExists{page_numbers.tex}{}{}
\newcommand*{\docutilsroleref}{\ref}
\newcommand*{\docutilsrolelabel}{\label}
\newcommand*\DUrolecode[1]{#1}
\providecommand*\DUrolecite[1]{\cite{#1}}
\begin{abstract}Live-cell imaging is a highly used technique to study cell migration and dynamics over time. Although many computational tools have been developed during the past years to automatically detect and track cells, they are optimized to detect cell nuclei with similar shapes and/or cells not clustering together. These existing tools are challenged when tracking fluorescently labelled membranes of cells due to cell's irregular shape, variability in size and dynamic movement across Z planes making it difficult to detect and track them.
Here we introduce a detailed analysis pipeline to perform segmentation with accurate shape information, combined with BTrackmate, a customized codebase of popular ImageJ/Fiji software Trackmate, to perform cell tracking inside the tissue of interest. We developed VollSeg, a new segmentation method able to detect membrane-labelled cells with low signal-to-noise ratio and dense packing. Finally, we also created an interface in Napari, an Euler angle based viewer, to visualize the tracks along a chosen view making it possible to follow a cell along the plane of motion. Importantly, we provide a detailed protocol to implement this pipeline in a new dataset, together with the required Jupyter notebooks. Our codes are open source available at \DUrole{cite}{Github2021}.\end{abstract}\begin{IEEEkeywords}3D segmentation, cell tracking, deep learning, irregular shaped cells, fluorescent microscopy.\end{IEEEkeywords}

\subsection{Introduction%
  \label{introduction}%
}
\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/Seg_pipe.png}}
\caption{Schematic representation showing the segmentation approach used in VollSeg. First, we input the raw fluorescent image in 3D (A) and pre-process it to remove noise. Next, we obtain the star convex approximation to the cells using Stardist (B) and the U-Net prediction labelled via connected components (C). We then obtain seeds from the centroids of labelled image in B, for each labelled region of C in order to create bounding boxes and centroids. If there is no seed from B in the bounding box region from U-Net, we add the new centroid (shown in yellow) to the seed pool (D). Finally, we do a marker controlled watershed in 3D using skimage implementation on the probability map shown in (E) to obtain the final cell segmentation result (F). All images are displayed in Napari viewer with 3D display view.}
\begin{DUlegend}

\DUrole{label}{algorithm}\end{DUlegend}
\end{figure}

Live-cell imaging is a highly used technique to study cell migration and dynamics over time. The image analysis workflow of volumetric (3D) imaging of cells via fluorescence microscopy starts with an accurate detection and segmentation of cells followed by cell tracking and track analysis. Broadly speaking the task of segmentation can be separated into semantic segmentation (classifying pixels as background or pixels belonging to the cell) or instance segmentation (classifying pixels belonging to individual cells by assigning a unique label to each cell). Segmentation is complicated due to presence of multiple objects in the image, overlapping object pixels and non-homogeneous intensity distribution. Several methods have been proposed for such automated detection and segmentation tasks such as the traditional intensity based thresholding, watershed transform \DUrole{cite}{Beucher2018} and of recent machine learning methods based on random-forest classifiers and support vector machines \DUrole{cite}{berg2019}. It was shown in \DUrole{cite}{Rasse2020} that conventional computer vision and machine learning based techniques alone will almost always lead to sub-optimal segmentation and that methods based on deep learning have improved the accuracy of segmentation for natural and biomedical images alike. For the purpose of semantic segmentation U-Net \DUrole{cite}{Ronn2015} has emerged as the most widely used network for biological applications. This network also forms the backbone of another successful network to do cell nuclei segmentation in 3D, Stardist \DUrole{cite}{schmidt2018} \DUrole{cite}{weigert2020}. Stardist directly predicts a shape representation as star-convex polygons for cell nuclei in 2D and 3D. However, cell membrane segmentation is especially challenging as opposed to nuclei segmentation due to fewer boundary pixels and the need to separate touching cells. To predict cell contours together with cell centroids, Eschweiler et al. proposed a 3D U-Net network using centroids as seeds for watershed in 3D confocal microscopy images \DUrole{cite}{eschweiler2018}. The drawback of this approach is misclassification due to sub-optimal seeding. Another approach proposed by Wolny et al., is to directly predict the cell boundaries using a 3D U-Net followed by a volume partitioning algorithm to segment each cell based on the boundary prediction \DUrole{cite}{Wolny2020}. This approach requires well defined cell boundaries, which may create segmentation errors in low signal-to-noise imaging conditions.

To address the issues with existing segmentation algorithms just described, we developed Vollseg. In brief we use Stardist in 3D to obtain a star convex shape approximation for the cells and extract the cell centroids from these polygons. We also train a 3D U-Net model to obtain a semantic segmentation map of the cells. We then perform a marker controlled watershed on the probability map of Stardist using the U-Net segmentation as a mask image to prevent the overflow of segmentation regions. To avoid the error of sub-optimal seeding we developed a seed pooling approach taking advantage of strength of both the Stardist and U-Net networks. We benchmark our segmentation result on a challenging dataset comprised of epithelial cells of mouse embryonic mammary glands with membrane labelling. These cells are highly irregular in shape and have a low signal-to-noise ratio to obtain an accurate segmentation only based on the boundary information. Using this dataset, we obtain different metrics showing that our approach is able to obtain shape approximation for the overlapping cells that go beyond the star convex shape. The complete segmentation pipeline is illustrated in Figure \DUrole{ref}{algorithm}.

For analysis of the cell migration behavior we need to reliably track the cells and obtain certain attributes such as signal intensity or changes over time of the distance between the cells and tissue boundary. Cell tracking is challenging due to erratic volumetric motion, occlusion and cell divisions. Tracking using only the centroid information may lead to wrong cell assigmements, hence we need to include other cell attributes such as the shape and intensity information while making the links between the cells in successive time frames. Trackmate is a popular tracking software that uses customizable cost matrix for solving the linear assignment problem and uses Jaqman linker as a second step to link segments of dividing and merging cells \DUrole{cite}{Tinevez2017}. In this paper, we introduce BTrackmate, a Fiji/ImageJ plugin to track the previously segmented cells. The major advantage of BTrackmate is the ability to track the cells inside a tissue. It allows the input of the cell and tissue segmentation image files and/or a csv file of the cell attributes. Furthermore, we also add some biological context in the tracking process where after segment linking is done a track inspector removes segments that are shorter than a user defined time length. Such short segments are unlikely to be true division events if they are too short and manually removing them can be tedious when many tracks are present. The users can choose this parameter in time units and can set it to 0 if removing such short segments is not required.

Finally, the tracking results obtained with BTrackmate are saved as an xml file that can be re-opened in an Euler angle based viewer in python called Napari, allowing volumetric viewing of the tracked cells using the track layer feature \DUrole{cite}{Ulicna2020}. We made a python package called napatrackmater to export the track xml file as tracks layer in Napari for dividing and non-dividing tracks. We provide a customized Napari widget to view selected tracks and obtain their cell migration attributes.

\subsection{Material and Methods%
  \label{material-and-methods}%
}


\subsubsection{Preparation of the dataset%
  \label{preparation-of-the-dataset}%
}


We used fluorescent microscopy images of mouse embryonic mammary glands stabilized in an ex vivo culture previously collected in the laboratory of Dr. S. Fre at Institut Curie. All images were acquired with an inverted confocal laser scanning microscope (e.g. Zeiss LSM780/880) equipped with long-working distance objectives to acquire high-resolution 3D image stacks. We acquired images of pixel size (22, 512, 512) with calibration of (3, 0.52, 0.52) micrometer.
The quality at which these images are acquired is determined by the spatial resolution of the used optical device, desired temporal resolution, duration of the experiment and depth of the acquired Z-stacks. We perform unsupervised image denoising \DUrole{cite}{krull2019} on our dataset, an algorithm we chose based on its performance compared to other methods \DUrole{cite}{Richardson72}, \DUrole{cite}{Lucy74}.
Post-restoration of the 3D images, we developed a method to perform the segmentation of the cells using deep learning techniques. We created a training dataset with hand drawn segmentation of 14 Z-stacks. We performed data augmentation on the microscopy images by denoising, adding Poisson and Gaussian noise, random rotations and flips to create 700 Z-stacks. We chose a patch size of (16, 128, 128) and created 11,264 patches for training Stardist and U-Net network. For the Stardist network we chose 192 rays to have a better shape resolution for the irregular shaped cells.

\subsubsection{Parameter Setting%
  \label{parameter-setting}%
}


Stardist predicts object instances based on probability threshold and non maximal suppression threshold to merge overlapping predictions. These parameters can be automatically determined using the optimize threshold program that we provide with the segmentation package. Higher values of the probability threshold yield fewer object instances, but avoids false positives. Higher values of the overlap threshold would lead to oversegmentation. We used 32 Z-stacks to determine the optimal parameters of probability threshold of 0.76 and non maximal suppression threshold of 0.3.

\subsubsection{Segmentation%
  \label{segmentation}%
}


As illustrated in Figure \DUrole{ref}{algorithm}, we first obtain the centroids of the star convex approximated cell shapes and create a seed pool with these centroid locations. Even with the optimized threshold values we find that the seeds can be sub-optimal as many cells instances with low signal are missed. In order to make the seed pool optimal we use the U-Net prediction to obtain a binary image of semantic segmentation, perform connected component analysis to label the image and obtain bounding boxes (computed using scikit-image \DUrole{cite}{scikit-image}, version 0.18.x) for each label in 3D. For each bounding box we search for a seed from the Stardist predicted seed pool. If a Stardist seed is found inside the bounding box, the centroid of the U-Net predicted bounding box is rejected else the centroid is added to the seed pool to make a complete set of seeds that we use to start a watershed process in 3D. We use the probability map of Stardist to start the watershed process to obtain a better shape approximation for the irregular shaped cells that goes beyond the star convex shape.

The code for the merging of U-Net and Stardist seeds is the following:
\begin{DUclass}{code}
\begin{DUclass}{python}
\begin{quote}
{\ttfamily \raggedright \noindent
\DUrole{keyword}{def}\DUrole{whitespace}{~}\DUrole{name}{\DUrole{function}{iou3D}}\DUrole{punctuation}{(}\DUrole{name}{box\_unet}\DUrole{punctuation}{,}~\DUrole{name}{centroid\_star}\DUrole{punctuation}{):}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{ndim}~\DUrole{operator}{=}~\DUrole{name}{\DUrole{builtin}{len}}\DUrole{punctuation}{(}\DUrole{name}{centroid\_star}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~\DUrole{name}{inside}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{False}}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{Condition}~\DUrole{operator}{=}~\DUrole{punctuation}{{[}}\DUrole{name}{Conditioncheck}\DUrole{punctuation}{(}\DUrole{name}{centroid\_star}\DUrole{punctuation}{,}~\DUrole{name}{box\_unet}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~\DUrole{name}{p}\DUrole{punctuation}{,}~\DUrole{name}{ndim}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~~\DUrole{keyword}{for}~\DUrole{name}{p}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{\DUrole{builtin}{range}}\DUrole{punctuation}{(}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{,}\DUrole{name}{ndim}\DUrole{punctuation}{){]}}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{inside}~\DUrole{operator}{=}~\DUrole{name}{\DUrole{builtin}{all}}\DUrole{punctuation}{(}\DUrole{name}{Condition}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{keyword}{return}~\DUrole{name}{inside}\DUrole{whitespace}{~\\
~\\
}\DUrole{keyword}{def}\DUrole{whitespace}{~}\DUrole{name}{\DUrole{function}{Conditioncheck}}\DUrole{punctuation}{(}\DUrole{name}{centroid\_centroid}\DUrole{punctuation}{,}~\DUrole{name}{box\_unet}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~~~\DUrole{name}{p}\DUrole{punctuation}{,}~\DUrole{name}{ndim}\DUrole{punctuation}{):}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{condition}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{False}}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{keyword}{if}~\DUrole{name}{centroid\_star}\DUrole{punctuation}{{[}}\DUrole{name}{p}\DUrole{punctuation}{{]}}~\DUrole{operator}{>=}~\DUrole{name}{box\_unet}\DUrole{punctuation}{{[}}\DUrole{name}{p}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
}~~\DUrole{operator}{\DUrole{word}{and}}~\DUrole{name}{centroid\_star}\DUrole{punctuation}{{[}}\DUrole{name}{p}\DUrole{punctuation}{{]}}~\DUrole{operator}{<=}~\DUrole{name}{box\_unet}\DUrole{punctuation}{{[}}\DUrole{name}{p}~\DUrole{operator}{+}~\DUrole{name}{ndim}\DUrole{punctuation}{{]}:}\DUrole{whitespace}{~\\
~\\
}~~~~~~~\DUrole{name}{condition}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{True}}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{keyword}{return}~\DUrole{name}{condition}
}
\end{quote}
\end{DUclass}
\end{DUclass}
The code for doing watershed in 3D using the complete set of seeds on the probability map of Stardist is the following:
\begin{DUclass}{code}
\begin{DUclass}{python}
\begin{quote}
{\ttfamily \raggedright \noindent
\DUrole{keyword}{def}\DUrole{whitespace}{~}\DUrole{name}{\DUrole{function}{WatershedwithMask3D}}\DUrole{punctuation}{(}\DUrole{name}{Image}\DUrole{punctuation}{,}~\DUrole{name}{Label}\DUrole{punctuation}{,}~\DUrole{name}{mask}\DUrole{punctuation}{,}~\DUrole{name}{grid}\DUrole{punctuation}{):}\DUrole{whitespace}{~\\
}~~\DUrole{comment}{\DUrole{single}{\#Image~=~ProbabilityMap~of~Stardist}}\DUrole{whitespace}{~\\
}~~\DUrole{comment}{\DUrole{single}{\#Label~=~Label~segmentation~image~of~Stardist}}\DUrole{whitespace}{~\\
}~~\DUrole{comment}{\DUrole{single}{\#Mask~=~U-Net~predicted~image~post~binarization}}\DUrole{whitespace}{~\\
}~~\DUrole{name}{properties}~\DUrole{operator}{=}~\DUrole{name}{measure}\DUrole{operator}{.}\DUrole{name}{regionprops}\DUrole{punctuation}{(}\DUrole{name}{Label}\DUrole{punctuation}{,}~\DUrole{name}{Image}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~\DUrole{name}{binaryproperties}~\DUrole{operator}{=}\DUrole{whitespace}{~\\
}~~\DUrole{name}{measure}\DUrole{operator}{.}\DUrole{name}{regionprops}\DUrole{punctuation}{(}\DUrole{name}{label}\DUrole{punctuation}{(}\DUrole{name}{mask}\DUrole{punctuation}{),}~\DUrole{name}{Image}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~\DUrole{name}{Coordinates}~\DUrole{operator}{=}~\DUrole{punctuation}{{[}}\DUrole{name}{prop}\DUrole{operator}{.}\DUrole{name}{centroid}~\DUrole{keyword}{for}~\DUrole{name}{prop}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{properties}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
}~~\DUrole{name}{BinaryCoordinates}~\DUrole{operator}{=}~\DUrole{punctuation}{{[}}\DUrole{name}{prop}\DUrole{operator}{.}\DUrole{name}{centroid}~\DUrole{keyword}{for}\DUrole{whitespace}{~\\
}~~\DUrole{name}{prop}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{binaryproperties}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
}~~\DUrole{name}{Binarybbox}~\DUrole{operator}{=}\DUrole{whitespace}{~\\
}~~\DUrole{punctuation}{{[}}\DUrole{name}{prop}\DUrole{operator}{.}\DUrole{name}{bbox}~\DUrole{keyword}{for}~\DUrole{name}{prop}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{binaryproperties}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
}~~\DUrole{name}{Coordinates}~\DUrole{operator}{=}~\DUrole{name}{\DUrole{builtin}{sorted}}\DUrole{punctuation}{(}\DUrole{name}{Coordinates}~\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~\DUrole{name}{key}\DUrole{operator}{=}\DUrole{keyword}{lambda}~\DUrole{name}{k}\DUrole{punctuation}{:}~\DUrole{punctuation}{{[}}\DUrole{name}{k}\DUrole{punctuation}{{[}}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{{]},}~\DUrole{name}{k}\DUrole{punctuation}{{[}}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{1}}}\DUrole{punctuation}{{]},}~\DUrole{name}{k}\DUrole{punctuation}{{[}}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{2}}}\DUrole{punctuation}{{]}{]})}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{keyword}{if}~\DUrole{name}{\DUrole{builtin}{len}}\DUrole{punctuation}{(}\DUrole{name}{Binarybbox}\DUrole{punctuation}{)}~\DUrole{operator}{>}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{:}\DUrole{whitespace}{~\\
}~~~~~~~\DUrole{keyword}{for}~\DUrole{name}{i}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{\DUrole{builtin}{range}}\DUrole{punctuation}{(}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{,}~\DUrole{name}{\DUrole{builtin}{len}}\DUrole{punctuation}{(}\DUrole{name}{Binarybbox}\DUrole{punctuation}{)):}\DUrole{whitespace}{~\\
~\\
}~~~~~~~~~~\DUrole{name}{box}~\DUrole{operator}{=}~\DUrole{name}{Binarybbox}\DUrole{punctuation}{{[}}\DUrole{name}{i}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
}~~~~~~~~~~\DUrole{name}{inside}~\DUrole{operator}{=}~\DUrole{punctuation}{{[}}\DUrole{name}{iou3D}\DUrole{punctuation}{(}\DUrole{name}{box}\DUrole{punctuation}{,}~\DUrole{name}{star}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~~~~~~~~~\DUrole{keyword}{for}~\DUrole{name}{star}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{Coordinates}\DUrole{punctuation}{{]}}\DUrole{whitespace}{~\\
~\\
}~~~~~~~~~~\DUrole{keyword}{if}~\DUrole{operator}{\DUrole{word}{not}}~\DUrole{name}{\DUrole{builtin}{any}}\DUrole{punctuation}{(}\DUrole{name}{inside}\DUrole{punctuation}{)}~\DUrole{punctuation}{:}\DUrole{whitespace}{~\\
}~~~~~~~~~~~~~~~~\DUrole{name}{Coordinates}\DUrole{operator}{.}\DUrole{name}{append}\DUrole{punctuation}{(}\DUrole{name}{BinaryCoordinates}\DUrole{punctuation}{{[}}\DUrole{name}{i}\DUrole{punctuation}{{]})}\DUrole{whitespace}{~\\
~\\
~\\
}~~\DUrole{name}{Coordinates}\DUrole{operator}{.}\DUrole{name}{append}\DUrole{punctuation}{((}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{,}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{,}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{0}}}\DUrole{punctuation}{))}\DUrole{whitespace}{~\\
}~~\DUrole{name}{Coordinates}~\DUrole{operator}{=}~\DUrole{name}{np}\DUrole{operator}{.}\DUrole{name}{asarray}\DUrole{punctuation}{(}\DUrole{name}{Coordinates}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~\DUrole{name}{coordinates\_int}~\DUrole{operator}{=}~\DUrole{name}{np}\DUrole{operator}{.}\DUrole{name}{round}\DUrole{punctuation}{(}\DUrole{name}{Coordinates}\DUrole{punctuation}{)}\DUrole{operator}{.}\DUrole{name}{astype}\DUrole{punctuation}{(}\DUrole{name}{\DUrole{builtin}{int}}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{markers\_raw}~\DUrole{operator}{=}~\DUrole{name}{np}\DUrole{operator}{.}\DUrole{name}{zeros\_like}\DUrole{punctuation}{(}\DUrole{name}{Image}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}~~\DUrole{name}{markers\_raw}\DUrole{punctuation}{{[}}\DUrole{name}{\DUrole{builtin}{tuple}}\DUrole{punctuation}{(}\DUrole{name}{coordinates\_int}\DUrole{operator}{.}\DUrole{name}{T}\DUrole{punctuation}{){]}}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{1}}}\DUrole{whitespace}{~\\
}~~\DUrole{operator}{+}~\DUrole{name}{np}\DUrole{operator}{.}\DUrole{name}{arange}\DUrole{punctuation}{(}\DUrole{name}{\DUrole{builtin}{len}}\DUrole{punctuation}{(}\DUrole{name}{Coordinates}\DUrole{punctuation}{))}\DUrole{whitespace}{~\\
}~~\DUrole{name}{markers}~\DUrole{operator}{=}~\DUrole{name}{morphology}\DUrole{operator}{.}\DUrole{name}{dilation}\DUrole{punctuation}{(}\DUrole{whitespace}{~\\
}~~\DUrole{name}{markers\_raw}\DUrole{operator}{.}\DUrole{name}{astype}\DUrole{punctuation}{(}\DUrole{literal}{\DUrole{string}{\DUrole{single}{'uint16'}}}\DUrole{punctuation}{),}~\DUrole{name}{morphology}\DUrole{operator}{.}\DUrole{name}{ball}\DUrole{punctuation}{(}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{2}}}\DUrole{punctuation}{))}\DUrole{whitespace}{~\\
~\\
}~~\DUrole{name}{watershedImage}~\DUrole{operator}{=}~\DUrole{name}{watershed}\DUrole{punctuation}{(}\DUrole{operator}{-}\DUrole{name}{Image}\DUrole{punctuation}{,}~\DUrole{name}{markers}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~\DUrole{name}{mask}~\DUrole{operator}{=}~\DUrole{name}{mask}\DUrole{operator}{.}\DUrole{name}{copy}\DUrole{punctuation}{())}\DUrole{whitespace}{~\\
}~~\DUrole{keyword}{return}~\DUrole{name}{watershedImage}\DUrole{punctuation}{,}~\DUrole{name}{markers}
}
\end{quote}
\end{DUclass}
\end{DUclass}


\subsubsection{Performance Metrics%
  \label{performance-metrics}%
}
Accuracy of segmentation results is assesed by comparing the obtained labels to the ground truth (GT) labels. The most commonly used metric is to compute intersection over union (IOU) score between the predicted and the GT label image.
We define GT, labels and IOU score as:

$GT = \{gt\}$, $SEG=\{seg\}$ are two sets of segmented objects.

$IOU(a, b)$ is the value of the IOU operation between two segmented objects a and b.

A threshold score value $\tau \in [0,1]$ is used to determine the true positive (TP), false positives (FP) and false negatives (FN) defined as:
$$TP=\{seg\in SEG, \exists~gt\in GT,~IOU(gt,seg)>\tau\}$$
$$FP = \{seg\in SEG,\forall~gt\in GT,~IOU(gt, set)<\tau\}$$
$$FN = \{gt\in GT, \forall~seg\in SEG,~IOU(gt, seg)<\tau\}$$

We use the Stardist implementation to compute accuracy scores which uses the hungarian method (scipy implementation) \DUrole{cite}{Kuhn1955} to compute an optimal matching to do a one to one assingement of predicted label to GT labels. This implementation avoids finding multiple TP for a given instance of GT.
We also compute precision (TP/(TP + FP)), recall (TP / (TP + FN)), F1 score (geometric mean of precision and recall) and accuracy score
$AP_\tau= \frac{TP_\tau}{TP_\tau+ FP_\tau + FN_\tau}$.
To evaluate the accuracy of our method in resolving the shape of the cells we compute the mean squared error (MSE) and structural similarity index measurment (SSIM) between the GT and obtained segmentation images post-binarization operation on the obtained instance segmentation maps. MSE shows a low score if the image is structurally closer to GT. SSIM score is higher if the two images are structurally more similar to each other.

\subsubsection{Detailed Procedure%
  \label{detailed-procedure}%
}


The software package we provide comes with training and prediction notebooks for training the base U-Net and Stardist networks on your own dataset. We provide jupyter notebooks to do so on local GPU servers and also on Google Colab.

\paragraph{Network Training%
  \label{network-training}%
}


In the first Jupyter notebook we create the dataset for U-Net and Stardist training. In the first cell of the notebook the required parameters are the path to your data that contains the folder of Raw and Segmentation images to create training pairs. Also to be specified is the name of the generated npz file along with the model directory to store the h5 files of the trained model and the model name.
\begin{DUclass}{code}
\begin{DUclass}{python}
\begin{quote}
{\ttfamily \raggedright \noindent
\DUrole{name}{Data\_dir}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'/data/'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{NPZ\_filename}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'VollSeg'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Model\_dir}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'/data/'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Model\_Name}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'VollSeg'}}}
}
\end{quote}
\end{DUclass}
\end{DUclass}
The model parameters are specified in the next notebook cell. These parameters are described as follows:
\begin{enumerate}
\renewcommand{\labelenumi}{\arabic{enumi})}
\item 

NetworkDepth = Depth of the network, with each increasing depth the image is downsampled by 2 hence the XYZ dimension of the data / 2\textasciicircum{}depth has to be greater than 1.
\item 

Epochs: training for longer epochs ensures a well converged network and requires longer GPU runtimes.
\item 

Learning rate is the parameter which controls the step size used in the optimization process and it should not be greater than 0.001 at the start of the training.
\item 

Batch size controls the number of images used for doing stochastic gradient descent and is a parameter limited by the GPU memory available, batch size < 10 should be optimal.
\item 

Patch X, Y, Z is the size used for making patches out of the image data. The original image is broken down into patches for training. Patch size is chosen based on having enough context for the network to learn the details at different scales.
\item 

Kernel is the receptive field of the neural network, usual choices are 3, 5 or 7. This is the size of the convolutional kernel used in the network.
\item 

n\_patches\_per\_image is the number of patches sampled for each image to create the npz file, choose an optimal value so that the file fits in the RAM memory.
\item 

Rays stand for the number of rays used to learn the distance map, low rays decreases the spatial resolution and high rays are able to resolve the shape better.
\item 

use\_gpu\_opencl is a boolean parameter that is set true if you want to do some opencl computations on the GPU, this requires GPU tools python package.
\item 

Before starting the U-Net training an npz file containing the paried Raw and Binary segmentation images needs to be created, by setting GenerateNPZ = True such a file is created.
\item 

If there are multiple GPU's available, the training of U-Net and Stardist can be split between the GPU's. Set TrainUNET = True  for training a U-Net network, create a copy of the notebook and only set TrainSTAR = True for training a Stardist network. If there are no multiple GPU's available, set all of these parameters in 10) and 11) to be True to create and train both the networks in a single notebook run.\end{enumerate}


The code to set the parameters is the following:
\begin{DUclass}{code}
\begin{DUclass}{python}
\begin{quote}
{\ttfamily \raggedright \noindent
\DUrole{comment}{\DUrole{single}{\#Network~training~parameters}}\DUrole{whitespace}{~\\
}\DUrole{name}{NetworkDepth}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{3}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Epochs}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{100}}}\DUrole{whitespace}{~\\
}\DUrole{name}{LearningRate}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{float}{1.0E-4}}}\DUrole{whitespace}{~\\
}\DUrole{name}{batch\_size}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{5}}}\DUrole{whitespace}{~\\
}\DUrole{name}{PatchX}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{128}}}\DUrole{whitespace}{~\\
}\DUrole{name}{PatchY}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{128}}}\DUrole{whitespace}{~\\
}\DUrole{name}{PatchZ}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{16}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Kernel}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{3}}}\DUrole{whitespace}{~\\
}\DUrole{name}{n\_patches\_per\_image}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{16}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Rays}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{192}}}\DUrole{whitespace}{~\\
}\DUrole{name}{startfilter}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{48}}}\DUrole{whitespace}{~\\
}\DUrole{name}{use\_gpu\_opencl}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{True}}\DUrole{whitespace}{~\\
}\DUrole{name}{GenerateNPZ}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{True}}\DUrole{whitespace}{~\\
}\DUrole{name}{TrainUNET}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{False}}\DUrole{whitespace}{~\\
}\DUrole{name}{TrainSTAR}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{False}}
}
\end{quote}
\end{DUclass}
\end{DUclass}
After the network has been trained it will save the configuration files of the training for both the networks along with the weight vector file as h5 files that will be used by the prediction notebook. For running the network prediction on XYZ shape images use the prediction notebook either locally or on Colab. In this notebook you only have to specify the path to the image and the model directory. The only two parameters to be set here are the number of tiles (for creating image patches to fit in the GPU memory) and min\_size in pixel units to discard segmented objects below that size. We perform the watershed operation on the probability map as a default. However, this operation can also be changed to use the distance map coming out of Stardist prediction instead by setting 'UseProbability' variable to false.
The code below operates on a directory of XYZ shape images:
\begin{DUclass}{code}
\begin{DUclass}{python}
\begin{quote}
{\ttfamily \raggedright \noindent
\DUrole{name}{ImageDir}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'data/tiffiles/'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{Model\_Dir}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'data/'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{SaveDir}~\DUrole{operator}{=}~\DUrole{name}{ImageDir}~\DUrole{operator}{+}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'Results/'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{UNETModelName}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'UNETVollSeg'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{StarModelName}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'VollSeg'}}}\DUrole{whitespace}{~\\
}\DUrole{name}{NoiseModelName}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'NoiseVoid'}}}\DUrole{whitespace}{~\\
~\\
}\DUrole{name}{UnetModel}~\DUrole{operator}{=}~\DUrole{name}{CARE}\DUrole{punctuation}{(}\DUrole{name}{config}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{None}}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{name}~\DUrole{operator}{=}~\DUrole{name}{UNETModelName}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{basedir}~\DUrole{operator}{=}~\DUrole{name}{Model\_Dir}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}\DUrole{name}{StarModel}~\DUrole{operator}{=}~\DUrole{name}{StarDist3D}\DUrole{punctuation}{(}\DUrole{name}{config}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{None}}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{name}~\DUrole{operator}{=}~\DUrole{name}{StarModelName}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{basedir}~\DUrole{operator}{=}~\DUrole{name}{Model\_Dir}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}\DUrole{name}{NoiseModel}~\DUrole{operator}{=}~\DUrole{name}{N2V}\DUrole{punctuation}{(}\DUrole{name}{config}\DUrole{operator}{=}\DUrole{keyword}{\DUrole{constant}{None}}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{name}\DUrole{operator}{=}\DUrole{name}{NoiseModelName}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}\DUrole{name}{basedir}\DUrole{operator}{=}\DUrole{name}{Model\_Dir}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
~\\
}\DUrole{name}{Raw\_path}~\DUrole{operator}{=}\DUrole{whitespace}{~\\
}\DUrole{name}{os}\DUrole{operator}{.}\DUrole{name}{path}\DUrole{operator}{.}\DUrole{name}{join}\DUrole{punctuation}{(}\DUrole{name}{ImageDir}\DUrole{punctuation}{,}~\DUrole{literal}{\DUrole{string}{\DUrole{single}{'*.tif'}}}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}\DUrole{name}{filesRaw}~\DUrole{operator}{=}\DUrole{whitespace}{~\\
}\DUrole{name}{glob}\DUrole{operator}{.}\DUrole{name}{glob}\DUrole{punctuation}{(}\DUrole{name}{Raw\_path}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}\DUrole{name}{filesRaw}\DUrole{operator}{.}\DUrole{name}{sort}\DUrole{whitespace}{~\\
}\DUrole{name}{min\_size}~\DUrole{operator}{=}~\DUrole{literal}{\DUrole{number}{\DUrole{integer}{50}}}\DUrole{whitespace}{~\\
}\DUrole{name}{n\_tiles}~\DUrole{operator}{=}~\DUrole{punctuation}{(}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{1}}}\DUrole{punctuation}{,}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{1}}}\DUrole{punctuation}{,}\DUrole{literal}{\DUrole{number}{\DUrole{integer}{1}}}\DUrole{punctuation}{)}\DUrole{whitespace}{~\\
}\DUrole{keyword}{for}~\DUrole{name}{fname}~\DUrole{operator}{\DUrole{word}{in}}~\DUrole{name}{filesRaw}\DUrole{punctuation}{:}\DUrole{whitespace}{~\\
~\\
}~~~~~\DUrole{name}{SmartSeedPrediction3D}\DUrole{punctuation}{(}\DUrole{name}{ImageDir}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~\DUrole{name}{SaveDir}\DUrole{punctuation}{,}~\DUrole{name}{fname}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~\DUrole{name}{UnetModel}\DUrole{punctuation}{,}~\DUrole{name}{StarModel}\DUrole{punctuation}{,}~\DUrole{name}{NoiseModel}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~\DUrole{name}{min\_size}~\DUrole{operator}{=}~\DUrole{name}{min\_size}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~\DUrole{name}{n\_tiles}~\DUrole{operator}{=}~\DUrole{name}{n\_tiles}\DUrole{punctuation}{,}\DUrole{whitespace}{~\\
}~~~~~\DUrole{name}{UseProbability}~\DUrole{operator}{=}~\DUrole{keyword}{\DUrole{constant}{False}}\DUrole{punctuation}{)}
}
\end{quote}
\end{DUclass}
\end{DUclass}


\subsubsection{Tracking%
  \label{tracking}%
}
After we obtain the segmentation using VollSeg, we create a csv file of the cell attributes that include their location, size and volume inside a region of interest. For large datasets memory usage could be of concern while loading the images into memory, hence inputs via csv could prove helpful. Tracking is performed in ImageJ/Fiji, an image processing package. We developed our code over the existing tracking solution called Trackmate \DUrole{cite}{Tinevez2017}. Trackmate uses linear assignment  problem (LAP) algorithm to do linking of the cells and uses Jaqman linker for linking the segments for dividing and merging trajectories. It also provides other trackers such as the Kalman filter to do tracking of non-dividing cells. Trackmate comes with a fully interactive track editing interface with graph listener to show the selected cell in the trackscheme and vice versa, to click on the graph and have the selected cell being highlighted in the image, making the process of track editing interactive. Post-editing the tracks are saved as an xml file which can then be loaded back into the program to do more track editing if needed. When a cell divides, the track is splitted up in two tracklets. In order to aid in track editing, we introduced a new parameter of minimum tracklet length to remove tracklets in a track that are short in the time dimension. This introduces a biological context of not having very short trajectories, reducing the track editing effort to correct for the linking mistakes made by the program. For testing our tracking program we used a freely available dataset from the cell tracking challenge of a developing C. elegans embryo \DUrole{cite}{Celegans} \DUrole{cite}{Murray2008}. Using our software we can remove cells from tracking which do not fit certain criteria such as being too small (hence most likely a segmentation mistake) or being low in intensity or outside the region of interest such as when we want to track cells only inside a tissue. For this dataset we kept 12,000 cells and after filtering short tracks kept about 50 tracks with and without division events.

For this dataset the track scheme along with overlayed tracks is shown in Figure \DUrole{ref}{trackscheme}. Selected node in the trackscheme is highlighted in green and vice versa. Extensive manual for using the track editing is available on ImageJ/Fiji wiki \DUrole{cite}{Fijiwiki}.\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/trackscheme.png}}
\caption{Trackscheme display for the C. elegans dataset.}
\begin{DUlegend}

\DUrole{label}{trackscheme}\end{DUlegend}
\end{figure}

\subsection{Results%
  \label{results}%
}


\subsubsection{Quantitative Comparisons between Segmentation Methods%
  \label{quantitative-comparisons-between-segmentation-methods}%
}
\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/Seg_compare-big.png}}
\caption{Visual 3D segmentation comparison between the Ground truth (GT) image, Stardist, U-Net and VollSeg results. The images are displayed in Napari viewer with 3D display view.}
\begin{DUlegend}

\DUrole{label}{visseg}\end{DUlegend}
\end{figure}

We compare our proposed VollSeg segmentation approach to two commonly used methods for cell segmentation of fluorescent microscopy images, 3D Stardist \DUrole{cite}{schmidt2018} \DUrole{cite}{weigert2020} and 3D U-Net \DUrole{cite}{Ronn2015}.
A 3D cell rendering using all analyzed segmentation methods is shown in the Figure \DUrole{ref}{visseg}.
Stardist in 3D was previously compared to other classical method, the IFT watershed, and it was shown to perform better than the classical method, hence we use Stardist as a baseline for comparison. To assess the performance of our segmentation, we compute the metrics described in material and methods section.
VollSeg and Stardist methods perform at comparable accuracy, but higher than U-Net, as shown in Figure \DUrole{ref}{metrics} A. This is expected, as U-Net can not perform instance segmentation of overlapping cells. In addition, when quantifying the F1-score in Figure \DUrole{ref}{metrics} B,  U-Net obtains the lowest score because it detects less TP segmented pixels in comparision to VollSeg and Stardist as shown in Figure \DUrole{ref}{metrics} C. However, Stardist has the highest mean squared error as it is unable to detect the irregular shape while U-Net and Vollseg have similar performance, as shown in Figure \DUrole{ref}{ssimmse} A. This result can also be seen from structural similarity index measurement, shown in Figure \DUrole{ref}{ssimmse} B. In conclusion, VollSeg is able to strength the shape accuracy from U-Net and the ability to separate the overlapping instances from Stardist.\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/Metrics.png}}
\caption{Segmentation comparision metrics between VollSeg (in blue), Stardist (in orange) and U-Net (in green). We plot (A) accuracy (as percentage), (B) F1 score (as percentage) and (C) true positive rates (as number of pixels) for all the networks.}
\begin{DUlegend}

\DUrole{label}{metrics}\end{DUlegend}
\end{figure}\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/Ssimmse.png}}
\caption{We plot Mean Squared error (MSE) (A) and Structural similarity index measurement (SSIM) (B)  comparing between VollSeg (in blue), Stardist (in orange) and U-Net (in green).}
\begin{DUlegend}\begin{quotation}
\begin{quote}

\DUrole{label}{ssimmse}\end{quote}
\end{quotation}\end{DUlegend}
\end{figure}

\subsubsection{Track Analysis%
  \label{track-analysis}%
}


After obtaining the tracks from BTrackmate, we save them as Trackmate xml file, which contains the information about all the cells in a track. Since the cells can be highly erratic in their volumetric motions, we use Napari, an Euler angle based viewer, to visualize such tracks from different reference positions.  We made a python package to export the xml files previously saved in ImageJ/Fiji and convert them into the tracks layer of Napari. We made a customised widget based graphic user interface (GUI) to view selected tracks, display the track information and save the cell track along user selected view, as shown in
Figure \DUrole{ref}{intensity-napari} A. On the top left panel, the image and tracks layer properties are displayed and can be changed (1). In the bottom left, there is a dropdown menu enlisting all the tracks (2). Users can select the track to be displayed in the central window and it can be switched between the hyperstack and the 3D view (3). The user can also choose to view all the tracks at once and then toggle the visibilty of the tracks using the eye icon next to the image and tracks layer (4). On the top right panel, we show two plots displaying the track information (5). The 3D central view can be rotated and translated to view the tracks along the plane of motion of the cells and the selected view can be saved as an animation using the bottom right animation panel (6). For the cells that divide we show the intensity variation and associated fast fourier transform for each tracklet.

We provide two example jupyter notebooks with the package. In the first one we compute the cell distance from the tissue boundary change over time for dividing and non-dividing trajectories. The user selects a track of interest and it displays two plots next to the track view that show the distance change over time for the whole track (non-dividing trajectory) and the starting and end location of the cells, as shown in Figure \DUrole{ref}{division-napari-start}. For the tracks with multiple events of cell division we show the distance change over time of each tracklet. In the localization plot the parent tracklet start and end location is shown in green while all the daughter cells start and end locations are shown in red. In the second example notebook, the plots show intensity change in the track over time along with the associated frequency of intensity oscillation present in each tracklet. The frequency associated with each tracklet is computed using the scipy implementation of fast fourier transform. The results of track analysis can be saved as plots, mp4 files of the track animation or csv files.\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/IntensityFFT.png}}
\caption{Napari widget to view tracks and plot track information in non-dividing trajectories (A) and dividing trajecrtories (B). For the selected track we see the intensity change over time and its associated fast Fourier transform.}
\begin{DUlegend}

\DUrole{label}{intensity-napari}\end{DUlegend}
\end{figure}\begin{figure}[]\noindent\makebox[\columnwidth][c]{\includegraphics[width=\columnwidth]{Figures/DistanceDividing2.png}}
\caption{Napari widget to analyze the distance of the cell to the boundary. The left plot displays the distance of the daughter cells to the boundary, while the right plot shows the start and end distance localization of the mother cell (in green) and daughter cells (in red).}
\begin{DUlegend}

\DUrole{label}{division-napari-start}\end{DUlegend}
\end{figure}

\subsection{Conclusions%
  \label{conclusions}%
}


We have presented a workflow to do segmentation, tracking and track analysis of cells in 3D with irregular shape and intensity distribution. For performing segmentation we developed VollSeg, a jupyter notebook based python package that combines the strengths of semantic and instance deep learning segmentation methods. Post-segmentation we create a csv file containing the information about the cells inside a region of interest which serves as an input to Btrackmate, the ImageJ/Fiji plugin we created for doing the tracking. The tracking software uses existing track editing interface of Trackmate and saves the track information as an xml file. To view and analyze such volumetric tracks we created napatrackmater, a python package to export such trajectories as track layer of Napari and we provide jupyter notebook based enviornment for track analysis with two example notebooks.

The tools that we present here can also be useful for segmentation of cells coming from other organisms or imaging modalities (transmitted light and light sheet imaging) as our method can be applied to segment cells that go beyond the star convex polyhedra.

\subsection{Acknowledgements%
  \label{acknowledgements}%
}


We acknowledge the Cell and Tissue Imaging Platform (PICT-IBiSA) of the Genetics and Developmental Biology Department (UMR3215/U934) at Institut Curie, member of the French National Reserch infrastructure France-Bioimaging (ANR-10-INBS-04). We thank specially Olivier Renaud for supporting the software development. We are grateful to Dr Silvia Fre for support and constructive discussions. We thank Leo Guginard for insightful comments about the manuscript. V.K is supported by Labex DEEP at Institut Curie (ANR-11- LBX0044 grant). C.C is supported by funding from the European Union's Horizon 2020 research and innovation programme under the Marie SkÅodowska-Curie grant agreement No 666003.

\subsection{Author Contributions%
  \label{author-contributions}%
}


V.K wrote the code; C.C performed the image acquisition of the used dataset and created labelled training dataset in 3D; V.K and C.C wrote the manuscript.
\bibliographystyle{alphaurl}
\bibliography{vkc}

\end{document}
